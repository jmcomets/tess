<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head><meta http-equiv="content-type" content="text/html; charset=utf-8"><link rel="shortcut icon" href="/media/img/effbot.ico"><link rel="stylesheet" href="/media/css/effbot-min.css" type="text/css" media="screen"><link rel="stylesheet" href="/media/css/effbotprint-min.css" type="text/css" media="print"><title>Understanding Python's "with"&nbsp;statement</title><script type="text/javascript">effbot_page_id=225;</script></head><body><div id="doc2" class="yui-t2"><div id="hd"><!-- header --></div><!-- hd --><div id="bd"><!-- body --><p class="note" style="text-align: center"><strong>

We're back after a server migration that caused effbot.org to fall
over a bit harder than expected.  Expect some glitches.

</strong></p><div id="yui-main"><div class="yui-b"><div class="content"><div class="yui-g"><h1 class="maintitle">Understanding Python's "with"&nbsp;statement</h1></div><!-- yui-g --><body>
<p class="info">Fredrik Lundh | October 2006 | Originally posted to <a href="http://online.effbot.org">online.effbot.org</a></p>
<p>Judging from comp.lang.python and other forums, Python 2.5&#8217;s new
<a href="http://effbot.org/pyref/with.htm"><b>with</b> statement</a>
seems to be a bit confusing even for experienced Python programmers.

</p><p>As most other things in Python, the <b>with</b> statement is
actually very simple, once you understand the problem it&#8217;s trying to
solve.  Consider this piece of code:

<pre class="python">
    set things up
    try:
        do something
    finally:
        tear things down
</pre>
</p><p>Here, &#8220;set things up&#8221; could be opening a file, or acquiring some
sort of external resource, and &#8220;tear things down&#8221; would then be
closing the file, or releasing or removing the resource.  The
<b>try-finally</b> construct guarantees that the &#8220;tear things down&#8221; part is
always executed, even if the code that does the work doesn&#8217;t finish.

</p><p>If you do this a lot, it would be quite convenient if you could put
the &#8220;set things up&#8221; and &#8220;tear things down&#8221; code in a library function,
to make it easy to reuse.  You can of course do something like

<pre class="python">
    def controlled_execution(callback):
        set things up
        try:
            callback(thing)
        finally:
            tear things down

    def my_function(thing):
        do something

    controlled_execution(my_function)
</pre>
</p><p>But that&#8217;s a bit verbose, especially if you need to modify local
variables.  Another approach is to use a one-shot generator, and use
the <b>for-in</b> statement to &#8220;wrap&#8221; the code:

<pre class="python">
    def controlled_execution():
        set things up
        try:
            yield thing
        finally:
            tear things down

    for thing in controlled_execution():
        do something with thing
</pre>
</p><p>But <b>yield</b> isn&#8217;t even allowed inside a <b>try-finally</b> in 2.4 and
earlier.  And while that could be fixed (and it has been fixed in 2.5),
it&#8217;s still a bit weird to use a loop construct when you know that you
only want to execute something once.

</p><p>So after contemplating a number of alternatives, GvR and the
python-dev team finally came up with a generalization of the latter,
using an object instead of a generator to control the behaviour of an
external piece of code:

<pre class="python">
    class controlled_execution:
        def <b>__enter__</b>(self):
            set things up
            return thing
        def <b>__exit__</b>(self, type, value, traceback):
            tear things down

    with controlled_execution() as thing:
         some code
</pre>
</p><p>Now, when the &#8220;with&#8221; statement is executed, Python evaluates the
expression, calls the <b>__enter__</b> method on the resulting value
(which is called a &#8220;context guard&#8221;), and assigns whatever
<b>__enter__</b> returns to the variable given by <b>as</b>.  Python
will then execute the code body, and <i>no matter what happens in that
code</i>, call the guard object&#8217;s <b>__exit__</b> method.

</p><p>As an extra bonus, the <b>__exit__</b> method can look at the
exception, if any, and suppress it or act on it as necessary.  To
suppress the exception, just return a true value.  For example, the
following <b>__exit__</b> method swallows any <b>TypeError</b>, but
lets all other exceptions through:

<pre class="python">
    def __exit__(self, type, value, traceback):
        return isinstance(value, TypeError)
</pre>
</p><p>In Python 2.5, the file object has been equipped with
<b>__enter__</b> and <b>__exit__</b> methods; the former simply
returns the file object itself, and the latter closes the file:

<pre class="python">
    &gt;&gt;&gt; f = open("x.txt")
    &gt;&gt;&gt; f
    &lt;open file 'x.txt', mode 'r' at 0x00AE82F0&gt;
    &gt;&gt;&gt; f.__enter__()
    &lt;open file 'x.txt', mode 'r' at 0x00AE82F0&gt;
    &gt;&gt;&gt; f.read(1)
    'X'
    &gt;&gt;&gt; f.__exit__(None, None, None)
    &gt;&gt;&gt; f.read(1)
    Traceback (most recent call last):
      File "&lt;stdin&gt;", line 1, in &lt;module&gt;
    ValueError: I/O operation on closed file
</pre>
</p><p>so to open a file, process its contents, and make sure to close it,
you can simply do:

<pre class="python">
with open("x.txt") as f:
    data = f.read()
    do something with data
</pre>
</p><p>This wasn&#8217;t very difficult, was it?</p></body><div class="yui-g"></div><!-- yui-g --></div><!-- content --></div><!-- yui-b --></div><!-- yui-main --><div class="yui-b"><div id='menu'></div><!-- menu --></div><!-- yui-b --></div><!-- bd --><div id="ft"><!-- footer --></div><!-- ft --></div><!-- doc --><script src="/media/js/effbot-min.js" type="text/javascript"></script></body></html>
